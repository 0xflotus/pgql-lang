module trans-for-nabl

imports

  signatures/-
  normalized-signatures
  common
  runtime/editor/-
  runtime/index/-
  runtime/nabl/-
  runtime/properties/-
  runtime/types/-
  runtime/task/-
  runtime/analysis/-

/*
 * 'trans-for-nabl' is called after 'normalize' and transforms the normalized AST into a shape that works for NaBL.
 *
 *  PGQL String -> PGQL AST -> PGQL normalized AST -> PGQL AST for NaBL -> GraphQuery object -> query plan
 */
rules

  trans-for-nabl = trans-query(|[], [])

rules

  trans-query(|vars, varsAggr):
    NormalizedQuery(pathPatterns, selectClause, fromClause, GraphPattern(vertices, edges, valueExpression), groupBy, having, orderBy, limitOffsets, error-messages, version) ->
        NormalizedQuery(pathPatterns, selectClause', fromClause, GraphPattern(vertices, edges, valueExpression'), groupBy', having', orderBy', limitOffsets, error-messages, version)
    with
       // FROM + MATCH
         new-vars := <collect((?Vertex(<id>) + ?Edge(_, <id>, _, _)); !VarDef(<id>, MatchClause(), None(), None()))> (vertices, edges)
       ; visible-vars := <replace-or-add-all> (new-vars, vars)

       // WHERE
       ; valueExpression' := <resolve-where-clause(|visible-vars, varsAggr)> valueExpression

       // GROUP BY
       ; if (!groupBy; ?Some(_)) + (!selectClause; contains-aggregation) + (!having; ?Some(_))
         then (groupBy', vars', varsAggr') := <resolve-group-by(|visible-vars, varsAggr)> groupBy
         else (groupBy', vars', varsAggr') := (groupBy, visible-vars, varsAggr)
         end

       // SELECT
       ; (selectClause', vars'') := <resolve-select-clause(|vars', varsAggr')> selectClause

       // HAVING
       ; having' := <resolve-var-refs(|vars'', varsAggr')> having

       // ORDER BY
       ; orderBy' := <resolve-var-refs(|vars'', varsAggr')> orderBy

  replace-or-add-all = foldl(replace-or-add)

  replace-or-add:
    (vd@VarDef(v, _, _, _), varDefs) -> <conc> (<remove-all(?VarDef(v, _, _, _))> varDefs, [vd])

  resolve-where-clause(|vars, varsAggr):
    valueExpression -> valueExpression'
    with valueExpression' := <resolve-var-refs(|vars, varsAggr)> valueExpression

  resolve-group-by(|vars, varsAggr):
    Some(GroupByClause(expAsVars)) -> (Some(GroupByClause(expAsVars')), vars', varsAggr')
    with (expAsVars', vars') := <foldl(resolve-group-by-helper(|vars, varsAggr))> (expAsVars, ([], []))
       ; varsAggr' := vars

  resolve-group-by-helper(|original-vars, varsAggr):
    (ExpAsVar(exp, v, anonymous), (result, vars)) -> (result', vars')
    with exp' := <resolve-var-refs(|original-vars, varsAggr)> exp // cannot reference other group variables defined on the left (may remove this restriction in the future)
       ; vars' := <replace-or-add> (VarDef(v, GroupByClause(), exp, exp'), vars)
       ; result' := <conc> (result, [ExpAsVar(exp', v, anonymous, GroupByClause())])

  resolve-group-by(|vars, varsAggr):
    None() -> (CreateOneGroup(), vars', varsAggr')
    with vars' := []
       ; varsAggr' := vars

  resolve-select-clause(|vars, varsAggr):
    SelectClause(distinct, eav@ExpAsVars(expAsVars)) -> (SelectClause(distinct, eav'), vars')
    with if Star() := expAsVars
         then eav' := expAsVars
            ; vars':= vars
         else (expAsVars', vars') := <foldl(resolve-select-clause-helper(|varsAggr))> (expAsVars, ([], vars))
            ; eav' := <origin-track-forced(!ExpAsVars(expAsVars'))> eav
         end

  resolve-select-clause-helper(|varsAggr):
    (ExpAsVar(exp, v, anonymous), (result, vars)) -> (result', vars')
    with exp' := <resolve-var-refs(|vars, varsAggr)> exp // can reference other select variables defined on the left
       ; vars' := <replace-or-add> (VarDef(v, SelectClause(), exp, exp'), vars)
       ; expAsVar' := ExpAsVar(exp', v, anonymous, SelectClause())
       ; result' := <conc> (result, [expAsVar'])

  resolve-var-refs(|vars, varsAggr) = alltd(resolve-var-ref(|vars, varsAggr)); alltd-in-outer-query-outside-aggregation(replace-exp-with-ref(|vars))

  resolve-var-ref(|vars, varsAggr):
    VarRef(v) -> varRef
    with varRef := <
        fetch(?VarDef(v, MatchClause(), _, _)); !VarRef(v, MatchClause())
        <+ fetch(?VarDef(v, GroupByClause(), _, _)); !VarRef(v, GroupByClause())
        <+ fetch(?VarDef(v, SelectClause(), _, _)); !VarRef(v, SelectClause())
        <+ !VarRef(v)
      > vars

  // MIN, MAX, SUM, AVG, ...
  resolve-var-ref(|vars, varsAggr):
    aggr -> <origin-track-forced(!aggr')> aggr
    where <is-aggregate> aggr
    with (cons, arguments) := <explode-term> aggr
       ; arguments' :=  <resolve-var-refs(|varsAggr, [])> arguments
       ; aggr' := <mkterm> (cons, arguments')

  resolve-var-ref(|vars, varsAggr):
    Subquery(query) -> Subquery(query')
    with query' := <trans-query(|vars, varsAggr)> query

  replace-exp-with-ref(|vars):
    exp -> varRef
    where not ( None() := exp )
        ; varRef := <fetch-elem(replace-exp-with-ref-helper(|exp))> vars

  replace-exp-with-ref-helper(|exp) = ?VarDef(v, clause, original-exp, _); where ( <eq> (exp, original-exp)); !VarRef(v, clause)
  replace-exp-with-ref-helper(|exp) = ?VarDef(v, clause, _, resolved-exp); where ( <eq> (exp, resolved-exp)); !VarRef(v, clause)

  contains-aggregation = collect-in-outer-query(is-aggregate); not ( ?[] )
