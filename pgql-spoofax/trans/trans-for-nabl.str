module trans-for-nabl

imports

  stratego/-
  signatures/-
  normalized-signatures
  common
  pp
  runtime/index/-
  runtime/nabl/-
  runtime/properties/-
  runtime/types/-
  runtime/task/-
  runtime/analysis/-
  runtime/editor/-

/*
 * 'trans-for-nabl' is called after 'normalize' and transforms the normalized AST into a shape that works for NaBL.
 *
 *  PGQL String -> PGQL AST -> PGQL normalized AST -> PGQL AST for NaBL -> GraphQuery object -> query plan
 */
rules

  trans-for-nabl = trans-query(|[], [])

rules

  trans-query(|vars, varsAggr):
    NormalizedQuery(CommonPathExpressions(pathExpressions), selectClause, fromClause, GraphPattern(vertices, edges, valueExpression), groupBy, having, orderBy, limitOffsets, error-messages, version) ->
        (crossReferences', NormalizedQuery(CommonPathExpressions(pathExpressions'), selectClause', fromClause, GraphPattern(vertices', edges', valueExpression'), groupBy', having', orderBy', limitOffsets, error-messages, version))
    with
       // PATH
         path-expression-return := <map(trans-path-expression(|vars))> pathExpressions
       ; pathExpressions' := <map(?(<id>, _))> path-expression-return
       ; crossReferences := <map(?(_, <id>)); concat> path-expression-return

       // FROM + MATCH
       ; (vertices', edges') := <alltd(add-offset)> (vertices, edges)
       ; new-vars := <collect(to-varDef)> (vertices', edges')
       ; (visible-vars, crossReferences') := <replace-or-add-all> (new-vars, (vars, crossReferences))

       // WHERE
       ; valueExpression' := <resolve-where-clause(|visible-vars, varsAggr)> valueExpression

       // GROUP BY
       ; if (!groupBy; ?Some(_)) + (!selectClause; contains-aggregation) + (!having; ?Some(_))
         then (groupBy', vars', varsAggr') := <resolve-group-by(|visible-vars, varsAggr)> groupBy
         else (groupBy', vars', varsAggr') := (groupBy, visible-vars, varsAggr)
         end

       // SELECT
       ; (selectClause', vars'') := <resolve-select-clause(|vars', varsAggr')> selectClause

       // HAVING
       ; having' := <resolve-var-refs(|vars'', varsAggr')> having

       // ORDER BY
       ; orderBy' := <resolve-var-refs(|vars'', varsAggr')> orderBy

  add-offset = ?Vertex(<id>); !Vertex(<id>, <origin-offset>)
  add-offset = ?Edge(src, <id>, dst, direction); !Edge(src, <id>, dst, direction, <origin-offset>)

  to-varDef = ?Vertex(name, origin-offset); !VarDef(name, MatchClause(VertexTy()), origin-offset, None(), None())
  to-varDef = ?Edge(_, name, _, _, origin-offset); !VarDef(name, MatchClause(EdgeTy()), origin-offset, None(), None())

  replace-or-add-all = foldl(replace-or-add)

  replace-or-add:
    (vd@VarDef(v, clause, _, _, _), (varDefs, crossReferences)) -> (varDefs', crossReferences')
    with if <fetch(?VarDef(v, _, _, _, _); ?VarDef(v-from-outer-query, clause-from-outer-query, origin-position-from-outer-query, _, _))> varDefs
         then varDefs' := <conc> (<remove-all(?VarDef(v, _, _, _, _))> varDefs, [vd])
            ; crossReferences' := <conc> (crossReferences, [CrossRef(VarRef(v-from-outer-query, clause-from-outer-query, origin-position-from-outer-query), v, clause)])
         else varDefs' := <conc> (varDefs, [vd])
            ; crossReferences' := crossReferences
         end

  resolve-where-clause(|vars, varsAggr):
    valueExpression -> valueExpression'
    with valueExpression' := <resolve-var-refs(|vars, varsAggr)> valueExpression

  resolve-group-by(|vars, varsAggr):
    Some(GroupByClause(expAsVars)) -> (Some(GroupByClause(expAsVars')), vars', varsAggr')
    with (expAsVars', vars') := <foldl(resolve-group-by-helper(|vars, varsAggr))> (expAsVars, ([], []))
       ; varsAggr' := vars

  resolve-group-by-helper(|original-vars, varsAggr):
    (ExpAsVar(exp, v, anonymous), (result, vars)) -> (result', vars')
    with exp' := <resolve-var-refs(|original-vars, varsAggr)> exp // cannot reference other group variables defined on the left (may remove this restriction in the future)
       ; (vars', _) := <replace-or-add> (VarDef(v, GroupByClause(), <origin-offset> v, exp, exp'), (vars, []))
       ; result' := <conc> (result, [ExpAsVar(exp', v, anonymous, GroupByClause(), <origin-offset> v)])

  resolve-group-by(|vars, varsAggr):
    None() -> (CreateOneGroup(), vars', varsAggr')
    with vars' := []
       ; varsAggr' := vars

  resolve-select-clause(|vars, varsAggr):
    SelectClause(distinct, eav@ExpAsVars(expAsVars)) -> (SelectClause(distinct, eav'), vars')
    with if Star() := expAsVars
         then eav' := expAsVars
            ; vars':= vars
         else (expAsVars', vars') := <foldl(resolve-select-clause-helper(|varsAggr))> (expAsVars, ([], vars))
            ; eav' := <origin-track-forced(!ExpAsVars(expAsVars'))> eav
         end

  resolve-select-clause-helper(|varsAggr):
    (ExpAsVar(exp, v, anonymous), (result, vars)) -> (result', vars')
    with exp' := <resolve-var-refs(|vars, varsAggr)> exp // can reference other select variables defined on the left
       ; if Anonymous() := anonymous; VarRef(_) := exp
         then vars' := vars // we don't want the second 'v' in 'SELECT v, v.prop' to reference to the first 'v'.
         else (vars', _) := <replace-or-add> (VarDef(v, SelectClause(), <origin-offset> v, exp, exp'), (vars, []))
         end
       ; expAsVar' := ExpAsVar(exp', v, anonymous, SelectClause(), <origin-offset> v)
       ; result' := <conc> (result, [expAsVar'])

  resolve-var-refs(|vars, varsAggr) = alltd(resolve-var-ref(|vars, varsAggr)); alltd-in-outer-query-outside-aggregation(replace-exp-with-ref(|vars))

  resolve-var-ref(|vars, varsAggr):
    VarRef(v) -> varRef
    with varRef := <
        fetch(?VarDef(v, MatchClause(ty), origin-offset, _, _)); !VarRef(v, MatchClause(ty), origin-offset)
        <+ fetch(?VarDef(v, GroupByClause(), origin-offset, _, _)); !VarRef(v, GroupByClause(), origin-offset)
        <+ fetch(?VarDef(v, SelectClause(), origin-offset, _, _)); !VarRef(v, SelectClause(), origin-offset)
        <+ !VarRef(v)
      > vars

  // MIN, MAX, SUM, AVG, ...
  resolve-var-ref(|vars, varsAggr):
    aggr -> <origin-track-forced(!aggr')> aggr
    where <is-aggregate> aggr
    with (cons, arguments) := <explode-term> aggr
       ; arguments' :=  <resolve-var-refs(|varsAggr, [])> arguments
       ; aggr' := <mkterm> (cons, arguments')

  resolve-var-ref(|vars, varsAggr):
    Subquery(query) -> Subquery(query')
    with query' := <trans-query(|vars, varsAggr)> query

  replace-exp-with-ref(|vars):
    exp -> varRef
    where not ( None() := exp )
        ; varRef := <fetch-elem(replace-exp-with-ref-helper(|exp))> vars

  replace-exp-with-ref-helper(|exp) = ?VarDef(v, clause, origin-offset, original-exp, _); where ( <eq> (exp, original-exp)); !VarRef(v, clause, origin-offset)
  replace-exp-with-ref-helper(|exp) = ?VarDef(v, clause, origin-offset, _, resolved-exp); where ( <eq> (exp, resolved-exp)); !VarRef(v, clause, origin-offset)

  contains-aggregation = collect-in-outer-query(is-aggregate); not ( ?[] )

  trans-path-expression(|vars):
    CommonPathExpression(name, vertices, edges, valueExpression) -> (CommonPathExpression(name, vertices', edges', valueExpression'), crossReferences)
    with
       // pattern
        (vertices', edges') := <alltd(add-offset)> (vertices, edges)
       ; new-vars := <collect(to-varDef)> (vertices', edges')
       ; (visible-vars, crossReferences) := <replace-or-add-all> (new-vars, (vars, []))

       // WHERE
       ; varsAggr := []
       ; valueExpression' := <resolve-where-clause(|visible-vars, varsAggr)> valueExpression
