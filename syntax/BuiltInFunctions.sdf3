module BuiltInFunctions

imports
  
  Keywords
  Names
  Expressions
  pgql-lang
  Literals

context-free syntax // inlined function calls

  InlinedCall.Label = <<Obj><LABEL>()>
  InlinedCall.Labels = <<Obj><LABELS>()>
  InlinedCall.HasLabel = <<Obj><HASLABEL>(<Exp>)>
  InlinedCall.Id = <<Obj><ID>()>
  InlinedCall.Has = <<Obj><HAS>(<{Prop ", "}*>)>
  InlinedCall.InDegree  = <<Obj><INDEGREE>()>
  InlinedCall.OutDegree = <<Obj><OUTDEGREE>()>
  
  InlinedCall.Nodes  = <<Obj><NODES>()>
  InlinedCall.Edges  = <<Obj><EDGES>()>
  InlinedCall.Length = <<Obj><LENGTH>()>

  Obj.Obj = <<VarRef><Dot>>
  Obj.Obj = <<Dot?>>

context-free syntax // nodes/edges

  Exp.Label = <<Exp>.<LABEL>()>
  Exp.Labels = <<Exp>.<LABELS>()>
  Exp.HasLabel = <<Exp>.<HASLABEL>(<Exp>)>
  Exp.Id = <<Exp>.<ID>()>
  Exp.Has = <<Exp>. <HAS>(<{Prop ", "}*>)>
  
context-free syntax // nodes

  Exp.InDegree  = <<Exp>. <INDEGREE>()>
  Exp.OutDegree = <<Exp>. <OUTDEGREE>()>
  
/* PGQL 1.0
context-free syntax // paths

  Exp.Nodes  = <<Exp>. <NODES>()>
  Exp.Edges  = <<Exp>. <EDGES>()>
  Exp.Length = <<Exp>. <LENGTH>()>

context-free syntax // Strings

  Exp.Contains   = <<Exp>. <CONTAINS>(<Exp>, <Exp>)>
  Exp.BeginsWith = <<Exp>. <BEGINSWITH>(<Exp>, <Exp>)>
  Exp.EndsWith   = <<Exp>. <ENDSWITH>(<Exp>, <Exp>)>

context-free syntax // Time

  Exp.Between = <<Exp>. <BETWEEN>(<Exp>, <Exp>)>
  Exp.Year = <<Exp>. <YEAR>()>
  Exp.Month = <<Exp>. <MONTH>()>
  Exp.Day = <<Exp>. <DAY>()>
  Exp.Hours = <<Exp>. <HOURS>()>
  Exp.Minutes = <<Exp>. <MINUTES>()>
  Exp.Seconds = <<Exp>. <SECONDS>()>
  Exp.Timezone = <<Exp>. <TIMEZONE>()>


context-free syntax // EXISTS / NOT EXISTS / CASE

  Exp.ExistsFunc    = <<EXISTS> <GroupGraphPattern>>
  Exp.Case          = <<CASE> <Exp> <{WhenThen " "}+> <ELSE> <Exp> <END>>
  WhenThen.WhenThen          = <<WHEN> <Exp> <THEN> <Exp>>
*/

context-free syntax // Aggregates

  Exp.COUNT        = <<COUNT>(<Distinct?><StarOrExp>)>
  Exp.MIN          = <<MIN>(<Distinct?><Exp>)>
  Exp.MAX          = <<MAX>(<Distinct?><Exp>)>
  Exp.SUM          = <<SUM>(<Distinct?><Exp>)>
  Exp.AVG          = <<AVG>(<Distinct?><Exp>)>
//  Exp.GROUP-CONCAT = <<GROUP-CONCAT>(<Distinct?><Exp><Group-Concat-Sep?>)> // PGQL 1.0
  
  StarOrExp.Star = <*>
  StarOrExp = <<Exp>>
  Group-Concat-Sep.Sep = <, <String>>
  Distinct.Distinct = DISTINCT

context-free priorities

  {
    right:
      Exp.UMin
      Exp.Not1
      Exp.Not2
  }
  >
 // all function calls should actually be in one block, but placing
 // too many sorts in one block crashes SDF2table gen. (Spoofax bug)
  {
    left:
      Exp.Label
      Exp.Labels
      Exp.HasLabel
      Exp.Id
      Exp.Has
      Exp.InDegree
      Exp.OutDegree
  }
  >
  {
    left:
      Exp.Mul
      Exp.Div
      Exp.Mod
      Exp.Regex
  }
  >
  {
    left:
      Exp.Add
      Exp.Sub
  }
  >
  {
    left:
      Exp.Gt
      Exp.Lt
      Exp.Gte
      Exp.Lte
  }
  >
  {
    left:
      Exp.Eq
      Exp.Neq
  }
  >
  {
    left:
      Exp.And
      Exp.And2
      Exp.And3
  }
  >
  {
    left:
      Exp.Or
      Exp.Or2
      Exp.Or3
  }

context-free priorities
 
  {
    right:
      InlinedExp.UMin
      InlinedExp.Not1
      InlinedExp.Not2
  }
  >
  {
    left:
      InlinedCall.Label
      InlinedCall.Labels
      InlinedCall.HasLabel
      InlinedCall.Id
      InlinedCall.Has
      InlinedCall.InDegree
      InlinedCall.OutDegree
  }
  >
  {
    left:
      InlinedCall.Nodes
      InlinedCall.Edges
      InlinedCall.Length
  }
  >
  {
    left:
      InlinedExp.Mul
      InlinedExp.Div
      InlinedExp.Mod
      InlinedExp.Regex
  }
  >
  {
    left:
      InlinedExp.Add
      InlinedExp.Sub
  }
  >
  {
    left:
      InlinedExp.Gt
      InlinedExp.Lt
      InlinedExp.Gte
      InlinedExp.Lte
  }
  >
  {
    left:
      InlinedExp.Eq
      InlinedExp.Neq
  }
  >
  {
    left:
      InlinedExp.And
      InlinedExp.And2
      InlinedExp.And3
  }
  >
  {
    left:
      InlinedExp.Or
      InlinedExp.Or2
      InlinedExp.Or3
  }
