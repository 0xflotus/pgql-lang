module BuiltInFunctions

imports
  
  Keywords
  Names
  Expressions
  PGQL
  Literals

context-free syntax // inlined function calls

  InlinedCall.Label = <<Obj><LABEL>()>
  InlinedCall.Labels = <<Obj><LABELS>()>
  InlinedCall.HasLabel = <<Obj><HASLABEL>(<Exp>)>
  InlinedCall.Id = <<Obj><ID>()>
  InlinedCall.Has = <<Obj><HAS>(<{Prop ", "}*>)>
  InlinedCall.InDegree  = <<Obj><INDEGREE>()>
  InlinedCall.OutDegree = <<Obj><OUTDEGREE>()>
  InlinedCall.Src = <<Obj><SRC>()>
  InlinedCall.Dst = <<Obj><DST>()>
  
  InlinedCall.Nodes  = <<Obj><NODES>()>
  InlinedCall.Edges  = <<Obj><EDGES>()>
  InlinedCall.Length = <<Obj><LENGTH>()>

  Obj.Obj = <<VarRef><Dot>>
  Obj.Obj = <<Dot?>>

context-free syntax // nodes/edges

  FunctionCall.Label = <<Exp>.<LABEL>()>
  FunctionCall.Labels = <<Exp>.<LABELS>()>
  FunctionCall.HasLabel = <<Exp>.<HASLABEL>(<Exp>)>
  FunctionCall.Id = <<Exp>.<ID>()>
  FunctionCall.Has = <<Exp>. <HAS>(<{Prop ", "}*>)>
  
context-free syntax // nodes

  FunctionCall.InDegree  = <<Exp>. <INDEGREE>()>
  FunctionCall.OutDegree = <<Exp>. <OUTDEGREE>()>
  
context-free syntax // edges

  FunctionCall.Src = <<Exp>. <SRC>()>
  FunctionCall.Dst = <<Exp>. <DST>()>

/* PGQL 1.0
context-free syntax // paths

  FunctionCall.Nodes  = <<Exp>. <NODES>()>
  FunctionCall.Edges  = <<Exp>. <EDGES>()>
  FunctionCall.Length = <<Exp>. <LENGTH>()>

context-free syntax // lists
  
  FunctionCall.Head = <<Exp>. <HEAD>()>
  FunctionCall.Last = <<Exp>. <LAST>()>
  FunctionCall.Init = <<Exp>. <INIT>()>
  FunctionCall.Tail = <<Exp>. <TAIL>()>

context-free syntax // Strings

  FunctionCall.Contains   = <<Exp>. <CONTAINS>(<Exp>, <Exp>)>
  FunctionCall.BeginsWith = <<Exp>. <BEGINSWITH>(<Exp>, <Exp>)>
  FunctionCall.EndsWith   = <<Exp>. <ENDSWITH>(<Exp>, <Exp>)>
*/

context-free syntax // Time

  FunctionCall.Between = <<Exp>. <BETWEEN>(<Exp>, <Exp>)>
  FunctionCall.Year = <<Exp>. <YEAR>()>
  FunctionCall.Month = <<Exp>. <MONTH>()>
  FunctionCall.Day = <<Exp>. <DAY>()>
  FunctionCall.Hours = <<Exp>. <HOURS>()>
  FunctionCall.Minutes = <<Exp>. <MINUTES>()>
  FunctionCall.Seconds = <<Exp>. <SECONDS>()>
  FunctionCall.Timezone = <<Exp>. <TIMEZONE>()>

/* PGQL 1.0
context-free syntax // EXISTS / NOT EXISTS / CASE

  FunctionCall.ExistsFunc    = <<EXISTS> <GroupGraphPattern>>
  FunctionCall.Case          = <<CASE> <Exp> <{WhenThen " "}+> <ELSE> <Exp> <END>>
  WhenThen.WhenThen          = <<WHEN> <Exp> <THEN> <Exp>>
*/

context-free syntax // Aggregates

  FunctionCall.COUNT        = <<COUNT>(<Distinct?><StarOrExp>)>
  FunctionCall.MIN          = <<MIN>(<Distinct?><Exp>)>
  FunctionCall.MAX          = <<MAX>(<Distinct?><Exp>)>
  FunctionCall.SUM          = <<SUM>(<Distinct?><Exp>)>
  FunctionCall.AVG          = <<AVG>(<Distinct?><Exp>)>
//  FunctionCall.GROUP-CONCAT = <<GROUP-CONCAT>(<Distinct?><Exp><Group-Concat-Sep?>)> // PGQL 1.0
  
  StarOrExp.Star = <*>
  StarOrExp = <<Exp>>
  Group-Concat-Sep.Sep = <, <String>>
  Distinct.Distinct = DISTINCT

context-free priorities

  {
    right:
      Exp.UMin
      Exp.Not1
      Exp.Not2
  }
  >
 // all function calls should actually be in one block, but placing
 // too many sorts in one block crashes SDF2table gen. (Spoofax bug)
  {
    left:
      FunctionCall.Label
      FunctionCall.Labels
      FunctionCall.HasLabel
      FunctionCall.Id
      FunctionCall.Has
      FunctionCall.InDegree
      FunctionCall.OutDegree
      FunctionCall.Src
      FunctionCall.Dst
  }
  >
  {
    left:
      FunctionCall.Between
      FunctionCall.Year
      FunctionCall.Month
      FunctionCall.Day
      FunctionCall.Hours
      FunctionCall.Minutes
      FunctionCall.Seconds
      FunctionCall.Timezone
  }
  >
  {
    left:
      Exp.Mul
      Exp.Div
      Exp.Mod
      Exp.Regex
  }
  >
  {
    left:
      Exp.Add
      Exp.Sub
  }
  >
  {
    left:
      Exp.Gt
      Exp.Lt
      Exp.Gte
      Exp.Lte
  }
  >
  {
    left:
      Exp.Eq
      Exp.Neq
  }
  >
  {
    left:
      Exp.And
      Exp.And2
      Exp.And3
  }
  >
  {
    left:
      Exp.Or
      Exp.Or2
      Exp.Or3
  }

context-free priorities
 
  {
    right:
      InlinedExp.UMin
      InlinedExp.Not1
      InlinedExp.Not2
  }
  >
  {
    left:
      InlinedCall.Label
      InlinedCall.Labels
      InlinedCall.HasLabel
      InlinedCall.Id
      InlinedCall.Has
      InlinedCall.InDegree
      InlinedCall.OutDegree
      InlinedCall.Src
      InlinedCall.Dst
  }
  >
  {
    left:
      InlinedCall.Nodes
      InlinedCall.Edges
      InlinedCall.Length
  }
  >
  {
    left:
      InlinedExp.Mul
      InlinedExp.Div
      InlinedExp.Mod
      InlinedExp.Regex
  }
  >
  {
    left:
      InlinedExp.Add
      InlinedExp.Sub
  }
  >
  {
    left:
      InlinedExp.Gt
      InlinedExp.Lt
      InlinedExp.Gte
      InlinedExp.Lte
  }
  >
  {
    left:
      InlinedExp.Eq
      InlinedExp.Neq
  }
  >
  {
    left:
      InlinedExp.And
      InlinedExp.And2
      InlinedExp.And3
  }
  >
  {
    left:
      InlinedExp.Or
      InlinedExp.Or2
      InlinedExp.Or3
  }
