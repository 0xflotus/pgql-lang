
module Paths
imports Keywords Literals Names Expressions BuiltInFunctions

exports
  context-free syntax
    Node EdgeNode+ VarAssign?                     -> Path                  {cons("Path")}
    "(" NoExpression? ")"                         -> Path                  {cons("SingleNode")}
    "(" ElemContents ")"                          -> Node                  {cons("Node")}
    VARNAME                                       -> Node                  {cons("SimpleNode")}
    Edge Node                                     -> EdgeNode              {cons("EdgeNode")}
    "-" EdgeContents? PathLengthConstraints? "->" -> Edge                  {cons("EdgeOut")}
    "<-" PathLengthConstraints? EdgeContents? "-" -> Edge                  {cons("EdgeIn")}
    "->"                                          -> Edge                  {cons("EdgeOut")}
    "<-"                                          -> Edge                  {cons("EdgeIn")}
    "-" EdgeContents? PathLengthConstraints? "-"  -> Edge                  {cons("EdgeNoDir")}
    "[" ElemContents "]"                          -> EdgeContents          {cons("EdgeContents")}
    "{" PathConstraint "}"                        -> PathLengthConstraints {cons("PathLengthConstraints")}
    INTEGER? ".." INTEGER?                        -> PathConstraint        {cons("PathLength")}

  context-free syntax
    CONTENTCOMPLETE -> Path                  {cons("COMPLETION-Path")}
    CONTENTCOMPLETE -> Node                  {cons("COMPLETION-Node")}
    CONTENTCOMPLETE -> EdgeNode              {cons("COMPLETION-EdgeNode")}
    CONTENTCOMPLETE -> Edge                  {cons("COMPLETION-Edge")}
    CONTENTCOMPLETE -> EdgeContents          {cons("COMPLETION-EdgeContents")}
    CONTENTCOMPLETE -> PathLengthConstraints {cons("COMPLETION-PathLengthConstraints")}
    CONTENTCOMPLETE -> PathConstraint        {cons("COMPLETION-PathConstraint")}

  context-free syntax
    VARNAME? Labels? Ids? WithInlinedConstraints? -> ElemContents           {cons("ElemContents")}
    VARNAME? Labels Ids? WithInlinedConstraints?  -> NoExpression           {cons("ElemContents1"), prefer}
    VARNAME? Labels? Ids WithInlinedConstraints?  -> NoExpression           {cons("ElemContents2")}
    VARNAME? Labels? Ids? WithInlinedConstraints  -> NoExpression           {cons("ElemContents3"), avoid}
    ":" AltLit                                    -> Labels                 {cons("Labels")}
    "@" AltLit                                    -> Ids                    {cons("Ids")}
    WITH {InlinedExp ","}+                        -> WithInlinedConstraints {cons("Constraint")}

  context-free syntax
    CONTENTCOMPLETE -> ElemContents           {cons("COMPLETION-ElemContents")}
    CONTENTCOMPLETE -> NoExpression           {cons("COMPLETION-NoExpression")}
    CONTENTCOMPLETE -> Labels                 {cons("COMPLETION-Labels")}
    CONTENTCOMPLETE -> Ids                    {cons("COMPLETION-Ids")}
    CONTENTCOMPLETE -> WithInlinedConstraints {cons("COMPLETION-WithInlinedConstraints")}