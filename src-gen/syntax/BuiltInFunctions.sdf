module BuiltInFunctions
imports Keywords Names Expressions PGQL Literals

exports
  context-free syntax
    Obj LABEL "()"              -> InlinedCall {cons("Label")}
    Obj ID "()"                 -> InlinedCall {cons("Id")}
    Obj HAS "(" {Prop ","}* ")" -> InlinedCall {cons("Has")}
    Obj INDEGREE "()"           -> InlinedCall {cons("InDegree")}
    Obj OUTDEGREE "()"          -> InlinedCall {cons("OutDegree")}
    Obj SRC "()"                -> InlinedCall {cons("Src")}
    Obj DST "()"                -> InlinedCall {cons("Dst")}
    Obj NODES "()"              -> InlinedCall {cons("Nodes")}
    Obj EDGES "()"              -> InlinedCall {cons("Edges")}
    Obj LENGTH "()"             -> InlinedCall {cons("Length")}
    VarRef Dot                  -> Obj         {cons("Obj")}
    Dot?                        -> Obj         {cons("Obj")}

  context-free syntax
    CONTENTCOMPLETE -> InlinedCall {cons("COMPLETION-InlinedCall")}
    CONTENTCOMPLETE -> Obj         {cons("COMPLETION-Obj")}

  context-free syntax
    Exp "." LABEL "()"              -> FunctionCall {cons("Label")}
    Exp "." ID "()"                 -> FunctionCall {cons("Id")}
    Exp "." HAS "(" {Prop ","}* ")" -> FunctionCall {cons("Has")}

  context-free syntax
    CONTENTCOMPLETE -> FunctionCall {cons("COMPLETION-FunctionCall")}

  context-free syntax
    Exp "." INDEGREE "()"  -> FunctionCall {cons("InDegree")}
    Exp "." OUTDEGREE "()" -> FunctionCall {cons("OutDegree")}

  context-free syntax
    CONTENTCOMPLETE -> FunctionCall {cons("COMPLETION-FunctionCall")}

  context-free syntax
    Exp "." SRC "()" -> FunctionCall {cons("Src")}
    Exp "." DST "()" -> FunctionCall {cons("Dst")}

  context-free syntax
    CONTENTCOMPLETE -> FunctionCall {cons("COMPLETION-FunctionCall")}

  context-free syntax
    Exp "." NODES "()"  -> FunctionCall {cons("Nodes")}
    Exp "." EDGES "()"  -> FunctionCall {cons("Edges")}
    Exp "." LENGTH "()" -> FunctionCall {cons("Length")}

  context-free syntax
    CONTENTCOMPLETE -> FunctionCall {cons("COMPLETION-FunctionCall")}

  context-free syntax
    Exp "." HEAD "()" -> FunctionCall {cons("Head")}
    Exp "." LAST "()" -> FunctionCall {cons("Last")}
    Exp "." INIT "()" -> FunctionCall {cons("Init")}
    Exp "." TAIL "()" -> FunctionCall {cons("Tail")}

  context-free syntax
    CONTENTCOMPLETE -> FunctionCall {cons("COMPLETION-FunctionCall")}

  context-free syntax
    Exp "." CONTAINS "(" Exp "," Exp ")"   -> FunctionCall {cons("Contains")}
    Exp "." BEGINSWITH "(" Exp "," Exp ")" -> FunctionCall {cons("BeginsWith")}
    Exp "." ENDSWITH "(" Exp "," Exp ")"   -> FunctionCall {cons("EndsWith")}

  context-free syntax
    CONTENTCOMPLETE -> FunctionCall {cons("COMPLETION-FunctionCall")}

  context-free syntax
    Exp "." BETWEEN "(" Exp "," Exp ")" -> FunctionCall {cons("Between")}
    Exp "." YEAR "()"                   -> FunctionCall {cons("Year")}
    Exp "." MONTH "()"                  -> FunctionCall {cons("Month")}
    Exp "." DAY "()"                    -> FunctionCall {cons("Day")}
    Exp "." HOURS "()"                  -> FunctionCall {cons("Hours")}
    Exp "." MINUTES "()"                -> FunctionCall {cons("Minutes")}
    Exp "." SECONDS "()"                -> FunctionCall {cons("Seconds")}
    Exp "." TIMEZONE "()"               -> FunctionCall {cons("Timezone")}

  context-free syntax
    CONTENTCOMPLETE -> FunctionCall {cons("COMPLETION-FunctionCall")}

  context-free syntax
    EXISTS GroupGraphPattern        -> FunctionCall {cons("ExistsFunc")}
    CASE Exp WhenThen+ ELSE Exp END -> FunctionCall {cons("Case")}
    WHEN Exp THEN Exp               -> WhenThen     {cons("WhenThen")}

  context-free syntax
    CONTENTCOMPLETE -> FunctionCall {cons("COMPLETION-FunctionCall")}
    CONTENTCOMPLETE -> WhenThen     {cons("COMPLETION-WhenThen")}

  context-free syntax
    COUNT "(" Distinct? StarOrExp ")"                    -> FunctionCall     {cons("COUNT")}
    MIN "(" Distinct? Exp ")"                            -> FunctionCall     {cons("MIN")}
    MAX "(" Distinct? Exp ")"                            -> FunctionCall     {cons("MAX")}
    SUM "(" Distinct? Exp ")"                            -> FunctionCall     {cons("SUM")}
    AVG "(" Distinct? Exp ")"                            -> FunctionCall     {cons("AVG")}
    GROUP-CONCAT "(" Distinct? Exp Group-Concat-Sep? ")" -> FunctionCall     {cons("GROUP-CONCAT")}
    "*"                                                  -> StarOrExp        {cons("Star")}
    Exp                                                  -> StarOrExp        
    "," String                                           -> Group-Concat-Sep {cons("Sep")}
    DISTINCT                                             -> Distinct         {cons("Distinct")}

  context-free syntax
    CONTENTCOMPLETE -> FunctionCall     {cons("COMPLETION-FunctionCall")}
    CONTENTCOMPLETE -> StarOrExp        {cons("COMPLETION-StarOrExp")}
    CONTENTCOMPLETE -> Group-Concat-Sep {cons("COMPLETION-Group-Concat-Sep")}

  context-free priorities
    {right:
      "-" Exp -> Exp
      NOT Exp -> Exp
      "!" Exp -> Exp
    } >
    {left:
      Exp "." LABEL "()" -> FunctionCall
      Exp "." ID "()" -> FunctionCall
      Exp "." HAS "(" {Prop ","}* ")" -> FunctionCall
      Exp "." INDEGREE "()" -> FunctionCall
      Exp "." OUTDEGREE "()" -> FunctionCall
      Exp "." SRC "()" -> FunctionCall
      Exp "." DST "()" -> FunctionCall
    } >
    {left:
      Exp "." NODES "()" -> FunctionCall
      Exp "." EDGES "()" -> FunctionCall
      Exp "." LENGTH "()" -> FunctionCall
      Exp "." HEAD "()" -> FunctionCall
      Exp "." LAST "()" -> FunctionCall
      Exp "." INIT "()" -> FunctionCall
      Exp "." TAIL "()" -> FunctionCall
    } >
    {left:
      Exp "." CONTAINS "(" Exp "," Exp ")" -> FunctionCall
      Exp "." BEGINSWITH "(" Exp "," Exp ")" -> FunctionCall
      Exp "." ENDSWITH "(" Exp "," Exp ")" -> FunctionCall
    } >
    {left:
      Exp "." BETWEEN "(" Exp "," Exp ")" -> FunctionCall
      Exp "." YEAR "()" -> FunctionCall
      Exp "." MONTH "()" -> FunctionCall
      Exp "." DAY "()" -> FunctionCall
      Exp "." HOURS "()" -> FunctionCall
      Exp "." MINUTES "()" -> FunctionCall
      Exp "." SECONDS "()" -> FunctionCall
      Exp "." TIMEZONE "()" -> FunctionCall
    } >
    {left:
      Exp "*" Exp -> Exp
      Exp "/" Exp -> Exp
      Exp "%" Exp -> Exp
      Exp "=~" Exp -> Exp
    } >
    {left:
      Exp "+" Exp -> Exp
      Exp "-" Exp -> Exp
    } >
    {left:
      Exp ">" Exp -> Exp
      Exp "<" Exp -> Exp
      Exp ">=" Exp -> Exp
      Exp "<=" Exp -> Exp
    } >
    {left:
      Exp "=" Exp -> Exp
      Exp "!=" Exp -> Exp
    } >
    {left:
      Exp "AND" Exp -> Exp
      Exp "and" Exp -> Exp
      Exp "And" Exp -> Exp
    } >
    {left:
      Exp "OR" Exp -> Exp
      Exp "or" Exp -> Exp
      Exp "Or" Exp -> Exp
    }

  context-free priorities
    {right:
      "-" InlinedExp -> InlinedExp
      NOT InlinedExp -> InlinedExp
      "!" InlinedExp -> InlinedExp
    } >
    {left:
      Obj LABEL "()" -> InlinedCall
      Obj ID "()" -> InlinedCall
      Obj HAS "(" {Prop ","}* ")" -> InlinedCall
      Obj INDEGREE "()" -> InlinedCall
      Obj OUTDEGREE "()" -> InlinedCall
      Obj SRC "()" -> InlinedCall
      Obj DST "()" -> InlinedCall
    } >
    {left:
      Obj NODES "()" -> InlinedCall
      Obj EDGES "()" -> InlinedCall
      Obj LENGTH "()" -> InlinedCall
    } >
    {left:
      InlinedExp "*" InlinedExp -> InlinedExp
      InlinedExp "/" InlinedExp -> InlinedExp
      InlinedExp "%" InlinedExp -> InlinedExp
      InlinedExp "=~" InlinedExp -> InlinedExp
    } >
    {left:
      InlinedExp "+" InlinedExp -> InlinedExp
      InlinedExp "-" InlinedExp -> InlinedExp
    } >
    {left:
      InlinedExp ">" InlinedExp -> InlinedExp
      InlinedExp "<" InlinedExp -> InlinedExp
      InlinedExp ">=" InlinedExp -> InlinedExp
      InlinedExp "<=" InlinedExp -> InlinedExp
    } >
    {left:
      InlinedExp "=" InlinedExp -> InlinedExp
      InlinedExp "!=" InlinedExp -> InlinedExp
    } >
    {left:
      InlinedExp "AND" InlinedExp -> InlinedExp
      InlinedExp "and" InlinedExp -> InlinedExp
      InlinedExp "And" InlinedExp -> InlinedExp
    } >
    {left:
      InlinedExp "OR" InlinedExp -> InlinedExp
      InlinedExp "or" InlinedExp -> InlinedExp
      InlinedExp "Or" InlinedExp -> InlinedExp
    }