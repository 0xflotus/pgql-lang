module syntax

language PGQL

test no-paths [[
MATCH
SELECT *
]] parse succeeds

test IN-clause [[
IN ldbc
MATCH x
SELECT *
]] parse succeeds

test case-insensitive-keywords [[
MaTcH x
sElEcT *
OrDeR bY x
]] parse succeeds

test comments-1 [[
MATCH x
 x // single-line comment
 
 /* multi-
  * line
  * comment
  */
SELECT x
]] parse succeeds

test comments-2 [[
MATCH x
 x # SPARQL comments are not allowed
SELECT x
]] parse fails

test string-literals [[
MATCH x
 x
 x.name = 'John'
 x.name = "John"
 x.name = "with'single'quotes"
 x.name = 'with"double"quotes'
 x.name = 'with\'single\'quotes'
 x.name = "with\"double\"quotes"
SELECT x
]] parse succeeds

test custom-data-types [[
MATCH x
 (x with name = 'John'^^myCustomType)
SELECT x
]] parse succeeds

test varDecl [[
MATCH x
 path1 := x -[e1]-> y
 path2 := y -[e2]-> z
 path3 := path1::path2 // path concat

 lit1 := 123
SELECT path3, l2 := lit1 + 1
]] parse succeeds

test pathsAndConstraints-1 [[
MATCH x
 x --> y    y --> z    z --> x // paths can be defined on a single-line, no comma is used for separation
 x.name = y.name and y.name = z.name
 x.name = y.name     y.name = z.name // same semantics as line above
SELECT x
]] parse succeeds

test pathsAndConstraints-2 [[
MATCH x
 x.name = y.name // constraints and paths can be defined in any order
 x --> y
 y.name = z.name
 z <-- y
SELECT x
]] parse succeeds

test arbitraryLengthPaths [[
MATCH x
  shortest := x -[:friendOf]{..}-> y
  shortest2 := x -[:friendOf]{..5}-> y
  shortest2 := x -[:friendOf]{1..}-> y
  shortest2 := x -[:friendOf]{1..5}-> y // min length 1, max length 5
SELECT x
]] parse succeeds

test shortestPaths [[
MATCH x
  shortest := x -[:friendOf]{shortest()}-> y
  weightedShortest := x -[e:friendOf]{shortest(e.p1 + e.p2)}-> y
SELECT x
]] parse succeeds

test aggregationAndSolutionModifiers [[
MATCH x
  x --> y
SELECT DISTINCT SUM(x.p1), MIN(x.p1), MAX(x.p1), GROUP_CONCAT(x.name), x.p2, x.p3
GROUP BY x
HAVING SUM(x.p1) >= 7
ORDER BY DESC(x.p3)
OFFSET 10
LIMIT 10
]] parse succeeds

test graphPatterns [[
MATCH x
  x --> y
  NOT EXISTS { y --> x }
  EXISTS { y --> z }
  
  {
    MATCH
      x --> z
    SELECT x, avg := MAX(z.p1)
  }
  
  { MATCH x --> (u with p1 > 7) SELECT u } UNION { MATCH x --> (u with p1 < 3) SELECT u } 
  
SELECT y, avg, u
]] parse succeeds
