module trans-for-nabl

imports
  
  src-gen/signatures/-
  sig-normalized
  sig-nabl
  common
  
/*
 * normalizeForNaBL is called after normalize. It's for extra transformations to get the AST in a shape that NaBL likes.
 *   PGQL -> PGQL AST -> PGQL norm. AST -> PGQL AST for NaBL ==> NaBL
 *                                      -> QueryGraph object ==> query planner
 */
rules
  
  transForNaBL = alltd(transForNaBL-grouping)
  
rules

  // if there is a GROUP BY then all variables in the SELECT need to be group keys or need to be inside aggregates
  transForNaBL-grouping:
    Query(fromClause, graphPattern, matchOrderHint, Select(distinctOrReduced, expAsVars, groupBy, having, orderBy, limitOffsets)) ->
    Query(fromClause, graphPattern, matchOrderHint, Select(distinctOrReduced, expAsVars', groupBy', having, orderBy', limitOffsets))
    where
      !groupBy; ?Some(_)
    with
      expAsVars' := <to-varOrGroupRefs> expAsVars;
      orderBy' := <to-groupRefs> orderBy;
      groupBy' := <to-groupDefs> groupBy

  // no GROUP BY but aggregations in SELECT
  transForNaBL-grouping:
    Query(fromClause, graphPattern, matchOrderHint, Select(distinctOrReduced, expAsVars, groupBy, having, orderBy, limitOffsets)) ->
    Query(fromClause, graphPattern, matchOrderHint, Select(distinctOrReduced, expAsVars', groupBy, having, orderBy', limitOffsets))
    where
      !groupBy; ?None(); !expAsVars; oncetd(is-aggregate)
    with
      expAsVars' := <create-errors-on-non-aggregations> expAsVars;
      orderBy' := <create-errors-on-non-aggregations> orderBy
      
  to-varOrGroupRefs = alltd(is-aggregate <+ ?VarRef(<id>); !GroupRef(<id>))
  to-groupRefs = alltd(is-aggregate <+ ?VarRef(<id>); !SelectOrGroupRef(<id>))
  create-errors-on-non-aggregations = alltd(
      (?ExpAsVar(_, <id>) + ?OrderByElem(<id>, _));
      not(is-aggregate); !NeedsToBeAnAggregation(<id>))
  
  to-groupDefs = alltd(to-groupDef)
  to-groupDef = ?ExpAsVar(v, exp); !ExpAsGroupVar(v, exp)
