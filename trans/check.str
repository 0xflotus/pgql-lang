module check

imports

  src-gen/signatures/-
  signatures-norm/-
  sig-normalized
  sig-nabl
  common
  lib/runtime/nabl/-
  lib/runtime/task/-
  lib/runtime/types/-
  lib/runtime/properties/-
  names

rules
  
  PGQL_VERSION = !"0.9"
 
// rules
//   
//   /**
//   * Error for undefined node property.
//   */
//   nabl-constraint(|lang, ctx, uri*):
//     PropRef(varRef, p) -> <fail>
//     where
//       <?VarRef(v) + ?GroupRef(v) + ?SelectOrGroupRef(v)> varRef;
//       v-resolve-task := <nabl-create-collectdefs(|ctx)> v;
//       v-prop-task    := <prop-create-lookup(|ctx, Type())> v-resolve-task;
//       m-resolve-task := <nabl-use-candidate(|lang, ctx, uri*, "schema")> UseCandidate(NablNsSchema(), [], Current(), False(), []);
//       m-prop-task    := <prop-create-lookup(|ctx, NablProp_data())> m-resolve-task;
//       rewrite-task1 := <task-create-rewrite(|ctx, "VarIsNode")> v-prop-task;
//       rewrite-task2 := <task-create-rewrite(|ctx, "NodePropExists")> (m-prop-task, p);
//       <task-create-error-on-failure(|ctx, rewrite-task2, [v-resolve-task, v-prop-task, rewrite-task1], $[Node property '[p]' does not exist])> p
// 
//   /**
//   * Error for undefined edge property.
//   */  
//   nabl-constraint(|lang, ctx, uri*):
//     PropRef(varRef, p) -> <fail>
//     where
//       <?VarRef(v) + ?GroupRef(v) + ?SelectOrGroupRef(v)> varRef;
//       v-resolve-task := <nabl-create-collectdefs(|ctx)> v;
//       v-prop-task    := <prop-create-lookup(|ctx, Type())> v-resolve-task;
//       m-resolve-task := <nabl-use-candidate(|lang, ctx, uri*, "schema")> UseCandidate(NablNsSchema(), [], Current(), False(), []);
//       m-prop-task    := <prop-create-lookup(|ctx, NablProp_data())> m-resolve-task;
//       rewrite-task1 := <task-create-rewrite(|ctx, "VarIsEdge")> v-prop-task;
//       rewrite-task2 := <task-create-rewrite(|ctx, "EdgePropExists")> (m-prop-task, p);
//       <task-create-error-on-failure(|ctx, rewrite-task2, [v-resolve-task, v-prop-task, rewrite-task1], $[Edge property '[p]' does not exist])> p
// 
//   task-rewrite: ("VarIsNode", NodeTy()) -> <id>
//   task-rewrite: ("VarIsEdge", EdgeTy()) -> <id>
//   task-rewrite: ("VarIsPath", PathTy()) -> <id>
//       
//   task-rewrite:
//     ("NodePropExists", (Schema(nprops, _), p)) -> <id> 
//     where
//       <strip-annos; fetch-elem(?NodeProp(p, _))> nprops
//     
//   task-rewrite:
//     ("EdgePropExists", (Schema(_, eprops), p)) -> <id>
//     where
//       <strip-annos; fetch-elem(?EdgeProp(p, _))> eprops      

rules // cross-constraints involving paths
  
  nabl-constraint(|ctx):
    Constraints(constraints) -> <fail>
    where
      <map(try(constraints-check(|ctx)))> constraints
      
  constraints-check(|ctx):
    constraint -> <fail>
    where
      varRefs := <collect-om(?VarRef(_))> constraint;
      <gt> (<length> varRefs, 1);
      <alltd(cross-constraints-paths(|ctx))> constraint
  
  cross-constraints-paths(|ctx):
    PropRef(VarRef(v), _) -> <fail>
    where
      var-is-path := <var-is-path(|ctx)> v;
      <task-create-error-on-success(|ctx, var-is-path, $[PGQL [<PGQL_VERSION>] does not allow to use cross-constraints that include path variables])> v

  var-is-edge(|ctx) = var-is-type(|ctx, "VarIsEdge")
  var-is-node(|ctx) = var-is-type(|ctx, "VarIsNode")
  var-is-path(|ctx) = var-is-type(|ctx, "VarIsPath")

  var-is-type(|ctx, type):
    v -> rewrite-task1
    where
      v-resolve-task := <nabl-create-collectdefs(|ctx)> v;
      v-prop-task    := <prop-create-lookup(|ctx, Type())> v-resolve-task;
      rewrite-task1  := <task-create-rewrite(|ctx, type)> v-prop-task

rules // subqueries
  
  nabl-constraint(|ctx):
    SubQueries(queries)  -> <fail>
    where
      <map(subquery-limitiation(|ctx))> queries
      
  subquery-limitiation(|ctx):
    e@Query(_, _, _, _) -> <id>
    where
      failtask := <task-create-fail(|ctx)>;
      <task-create-error-on-failure(|ctx, failtask, $[PGQL [<PGQL_VERSION>] does not allow subqueries])> e

rules // (NOT) EXISTS limitations
  
  constraints-check(|ctx):
    e@ExistsFunc(_) -> <fail>
    where
      failtask := <task-create-fail(|ctx)>;
      <task-create-error-on-failure(|ctx, failtask, $[PGQL [<PGQL_VERSION>] does not allow (NOT) EXISTS])> e

/*
  The following checks are for our C++ backend. I commented them out because they are not relevant for our Java backend.

  constraints-check(|ctx):
    constraint -> <fail>
    where
      not ( ?ExistsFunc(_) + ?Not(ExistsFunc(_)));
      oncetd(?e@ExistsFunc(_));
      failtask := <task-create-fail(|ctx)>;
      <task-create-error-on-failure(|ctx, failtask, "PGX 1.0 currently only supports top-level NOT EXISTS; the NOT EXISTS may not appear as part of a more complex expression")> e
      
  constraints-check(|ctx):
    e@Not(ExistsFunc(GraphPattern(_, Edges(edges), _, _, _, _, _, _))) -> <fail>
    where
      <gt> (<length> edges, 1);
      failtask := <task-create-fail(|ctx)>;
      <task-create-error-on-failure(|ctx, failtask, "PGX 1.0 currently only supports NOT EXISTS patterns with at most one edge")> e

  nabl-constraint(|ctx):
    Constraints(constraints) -> <fail>
    where
      notExists := <filter(?Not(ExistsFunc(_)))> constraints;
      <gt> (<length> notExists, 1);
      <Tl; map(task-create-error-on-failure(|ctx, <task-create-fail(|ctx)>, "PGX 1.0 currently only handles queries with at most one NOT EXISTS patterns"))> notExists

  nabl-constraint(|ctx):
    GraphPattern(Nodes(nodes), _, Constraints(constraints), _, _, _, _, _) -> <fail>
    where
      notExists := <filter(?Not(ExistsFunc(_)))> constraints;
      map(try(notExists-shares-variable-check(|ctx, nodes)))

  notExists-shares-variable-check(|ctx, nodesOuterScope):
    e@Not(ExistsFunc(GraphPattern(Nodes(nodes), _, _, _, _, _, _, _))) -> <fail>
    where
      not ( [] := <isect> (nodesOuterScope, nodes) );
      failtask := <task-create-fail(|ctx)>;
      <task-create-error-on-failure(|ctx, failtask, "PGX 1.0 does not support NOT EXISTS patterns that have no node variable in commont with the outer scope")> e
  */
  
rules // DISTINCT limitation
  
  nabl-constraint(|ctx):
    e@Distinct() -> <fail>
    with
      <generate-error(|ctx, $[PGQL [<PGQL_VERSION>] does not allow use of DISTINCT])> e

rules // Unsupported functions
  
  nabl-constraint(|ctx):
    t -> <fail>
    where
      <?Src(_) + ?Dst(_)
       + ?Nodes(_) + ?Edges(_) + ?Length(_)
       + ?Head(_) + ?Last(_) + ?Init(_) + ?Tail(_)
       + ?Contains(_, _, _) + ?BeginsWith(_, _, _) + ?EndsWith(_, _, _)
       + ?Year(_) + ?Month(_) + ?Day(_) + ?Hours(_) + ?Minutes(_) + ?Seconds(_) + ?Timezone(_)
       + ?Case(_, _, _)
      > t;
      funcName := <get-constructor> t;
      failtask := <task-create-fail(|ctx)>;
      <task-create-error-on-failure(|ctx, failtask, $[No such function in PGQL [<PGQL_VERSION>]: '[funcName]'])> t

rules // Not a connected graph, e.g. WHERE x -> y, x2 -> y2
  
  nabl-constraint(|ctx):
    GraphPattern(Nodes(nodes), Edges(edges), _, _, _, _, _, _) -> <fail>
    where
      sorted-partitions := <strip-annos; partition(|edges); reverse; qsort(length-gt)> nodes;
      biggest-partition := <Hd> sorted-partitions;
      other-partitions := <Tl> sorted-partitions
    with
      <map(connected-pattern-constraint(|ctx, biggest-partition))> other-partitions

  connected-pattern-constraint(|ctx, biggest-partition):
    other-partition -> <id>
    with
      if 1 := <length> biggest-partition
      then
        m := $[Node [<Hd> other-partition] is not connected to node [<Hd> biggest-partition]]
      else
        if 1 := <length> other-partition
        then m := $[Node [<Hd> other-partition] is not connected to nodes [<print-nodes> biggest-partition]]
        else m := $[Nodes [<print-nodes> other-partition] are not connected to nodes [<print-nodes> biggest-partition]]
        end
      end;
      <connected-pattern-constraint-helper(|ctx, m)> other-partition

  connected-pattern-constraint-helper(|ctx, message):
    node -> <id>
    with
      failtask := <task-create-fail(|ctx)>;
      <task-create-error-on-failure(|ctx, failtask, message)> node

  print-nodes = reverse; separate-by(|", "); concat-strings

  length-gt = ?(l1, l2); !(<length> l1, <length> (l2)); gt

  partition(|edges):
    nodes -> partitions
    with
      nodes' := <map(?Node(<id>))> nodes;
      if [] := nodes
      then
        partitions := []
      else
        someNode := <Hd; get-reachable-nodes(|edges)> nodes';
        partitions := <partition-helper(|nodes', edges)> [someNode]
      end
      
  partition-helper(|nodes, edges):
    partitions -> partitions'
    with
      covered := <concat> partitions;
      uncovered := <diff> (nodes, covered);
      if [] := uncovered
      then
        partitions' := partitions
      else
        partition := <Hd; get-reachable-nodes(|edges)> uncovered;
        partitions' := <partition-helper(|nodes, edges)> [partition|partitions]
      end

  get-reachable-nodes(|edges):
    x -> result
    with
      nodes := <is-list <+ ![<id>]> x;
      nodes' := <map(get-reachable-nodes-helper(|edges));  concat; make-set> nodes;
      if <eq> (<length> nodes, <length> nodes')
      then result := nodes'
      else result := <get-reachable-nodes(|edges)> nodes'
      end

  get-reachable-nodes-helper(|edges):
    node -> result
    with
      outNeighbors := <filter(?Edge(node, _, <id>, _))> edges;
      inNeighbors := <filter(?Edge(<id>, _, node, _))> edges;
      result := <conc> (outNeighbors, inNeighbors, [node])

rules // data types
  
  nabl-constraint(|ctx):
    LitCustomType(_, type) -> <fail>
    with
      <generate-error(|ctx, $[PGQL [<PGQL_VERSION>] does not support custom data types])> type
  
rules // Unresolved references
  
  nabl-check-disable-unresolved = id
  nabl-check-disable-duplicate(|uri, ns) = id
    
  nabl-constraint(|ctx):
    VarRef(v) -> <fail>
    where
      resolve-task := <nabl-create-collectdefs(|ctx)> v;
      <task-create-error-on-failure(|ctx, resolve-task, "Unresolved variable")> v
      
  nabl-constraint(|ctx):
    GroupRef(v) -> <fail>
    where
      resolve-task := <nabl-create-collectdefs(|ctx)> v;
      <task-create-error-on-failure(|ctx, resolve-task, "Non-group key variable in SELECT")> v
      
  nabl-constraint(|ctx):
    SelectOrGroupRef(v) -> <fail>
    where
      resolve-task := <nabl-create-collectdefs(|ctx)> v;
      <task-create-error-on-failure(|ctx, resolve-task, "Cannot order by non-group key variable without using aggregation")> v
      
  nabl-constraint(|ctx):
    expAsVar -> <fail>
    where
      <?ExpAsVar(v, _) + ?ExpAsGroupVar(v, _)> expAsVar;
    	// if ExpAsVar(v, _) := expAsVar
    	// then
     //    if <is-substring(GENERATED)> v
     //    then msg := "Duplicate expression in SELECT"
     //    else msg := "Duplicate variable"
     //    end
     //  else
     //  	ExpAsGroupVar(v, _) := expAsVar;
     //  	msg := "Duplicate variable"
     //  end;
      uri := <nabl-uri; nabl-uri-parent> v;
      resolve-task := <nabl-create-resolvedefs(|ctx, NablNsVar(), v, [])> uri;
      <task-create-error-on-multiple(|ctx, resolve-task, "Duplicate variable definition")> v

  nabl-constraint(|ctx):
    Edge(_, e, _, _) -> <fail>
    where
      uri := <nabl-uri; nabl-uri-parent> e;
      resolve-task := <nabl-create-resolvedefs(|ctx, NablNsVar(), e, [])> uri;
      <task-create-error-on-multiple(|ctx, resolve-task, "Duplicate edge variable")> e

rules
      
  // SELECT * in combination with GROUP BY
  // nabl-constraint(|ctx):
  //   Query(_, whereClause, _, Select(_, s@Star(), Some(groupClause), _, _, _)) -> <fail>
  //   with
  //     vars := <collect(get-name-of-var-def; not(is-substring(GENERATED)))> whereClause;
  //     groupKeys := <collect(?ExpAsGroupVar(_, VarRef(<id>)))> groupClause
  //   where
  //     not ( [] := <strip-annos; diff> (vars, groupKeys) )
  //   with
  //     failtask := <task-create-fail(|ctx)>;
  //     <task-create-error-on-failure(|ctx, failtask, "SELECT * only allowed in combination with GROUP BY if all variables in the WHERE clause are group keys")> s

  get-name-of-var-def = ?Node(<id>) + ?Edge(_, <id>, _, _)
  
rules // in-lined constraints
  
  nabl-constraint(|ctx):
    ReferenceInInlinedConstraint(v) -> <fail>
    with
      <generate-error(|ctx, $['[v]' should be omitted here])> v
  
  nabl-constraint(|ctx):
    t@CrossReferenceInInlinedConstraint() -> <fail>
    with
      <generate-error(|ctx, "In-lined constraint may not access other variables")> t

rules

  // expressions in SELECT, ORDER BY
  nabl-constraint(|ctx):
    t -> <fail>
    where
      <?ExpAsVars(_) + ?OrderClause(_)> t
    with
      exps := <not-supported-expressions> t;
      <batch-generate-errors(|ctx, "Only simple expressions allowed here (variable, property access, aggregation or function call)")> exps;
      expsInAggr := <not-supported-expressions-in-aggregration> t;
      <batch-generate-errors(|ctx, "Only simple expressions allowed here (variable, property access or function call)")> expsInAggr

 // expressions in GROUP BY
  nabl-constraint(|ctx):
    t@GroupClause(_) -> <fail>
    with
      exps := <not-supported-expressions> t;
      <batch-generate-errors(|ctx, "Only simple expressions allowed here (variable, property access or function call)")> exps;
      aggregations := <collect-om(is-aggregate, conc)> t;
      <batch-generate-errors(|ctx, "Aggregation not allowed in GROUP BY")> aggregations
      
  not-supported-expressions = collect-om(is-aggregate <+ is-function <+ is-expression <+ is-literal, conc); remove-all(is-aggregate + is-function)
  not-supported-expressions-in-aggregration = collect-om(is-aggregate, conc); collect-om(is-expression <+ is-literal, conc)
  
  // Nested aggregation
  nabl-constraint(|ctx):
    t -> <fail>
    where
      <is-aggregate> t
    with
      aggrsInAggr := <get-arguments; collect-om(is-aggregate, conc)> t;
      <batch-generate-errors(|ctx, "Nested aggregation is not allowed")> aggrsInAggr  
  
  nabl-constraint(|ctx):
    t@Regex(_, _) -> <fail>
    with
      <generate-error(|ctx, $[PGQL [<PGQL_VERSION>] does not support regular expressions])> t
      
  nabl-constraint(|ctx):
    PathDecl(v, _, _, _) -> <fail>
    with
      <generate-error(|ctx, $[PGQL [<PGQL_VERSION>] does not support path variables])> v

rules // helper rules

  batch-generate-errors(|ctx, m) = map(generate-error(|ctx, m))
    
  generate-error(|ctx, m):
    t -> <id>
    with
      failtask := <task-create-fail(|ctx)>;
      <task-create-error-on-failure(|ctx, failtask, m)> t
      
signature constructors
  
  ReferenceInInlinedConstraint : var -> ReferenceInInlinedConstraint
  CrossReferenceInInlinedConstraint : CrossReferenceInInlinedConstraint
  