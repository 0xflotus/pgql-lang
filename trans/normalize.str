module normalize

imports
  
  src-gen/signatures/-
  signatures-norm/-
  sig-normalized
  sig-nabl
  runtime/editor/origins
  common
  pp
  editor-common.generated
  check
  
/*
 * These transformations are shared by analysis, tree-to-model tranformation and code gen
 */
  
rules
  
  normalize-before:
    ast -> result
    with
      c := <new-counter>;
      result := <
      	bottomup(try(norm-case-insensitive));
        innermost(
          norm-UMin +
          norm-NOT +
          norm-singleNode +
          norm-edgeContents +
          norm-path-constraints
        );
        alltd(norm-string);
        alltd(norm-has-prop);
        alltd(name-unnamed-nodes-and-edges(|c));
        alltd(norm-path-constraints);
        alltd(norm-inlined-references);
        bottomup(try(
           // norm-UnionGraphPattern +
           // norm-NOT-EXISTS +
           norm-matchElems
        ));
        bottomup(try(norm-query(|c)))
      > ast

rules

  norm-UMin = ?UMin(Integer(string)); !Integer(<conc-strings> ("-", string))
  norm-UMin = ?UMin(Decimal(string)); !Integer(<conc-strings> ("-", string))
  norm-UMin = ?UMin(Double(string)); !Integer(<conc-strings> ("-", string))
  
  norm-NOT = ?Not1(_, <id>); !Not(<id>)
  norm-NOT = ?Not2(<id>); !Not(<id>)
  
  norm-string = is-string; try(un-double-quote + un-single-quote)
  
  norm-path-constraints = ?PathLengthConstraints(<id>)
  
rules
  
  norm-singleNode = ?SingleNode(Some(ElemContents1(a, b, c, d))); !Path(Node(ElemContents(a, Some(b), c, d)), [], None())
  norm-singleNode = ?SingleNode(Some(ElemContents2(a, b, c, d))); !Path(Node(ElemContents(a, b, Some(c), d)), [], None())
  norm-singleNode = ?SingleNode(Some(ElemContents3(a, b, c, d))); !Path(Node(ElemContents(a, b, c, Some(d))), [], None())
  norm-singleNode = ?Constraint(VarRef(<id>)); !Path(SimpleNode(<id>), [], None()); oncetd(norm-singleNode)
  norm-singleNode =?SimpleNode(<id>); !Node(ElemContents(Some(<id>), None(), None(), None()))  
  norm-edgeContents = ?Some(EdgeContents(<id>))
  
  name-unnamed-nodes-and-edges(|c) = ?ElemContents(None(), type, id', constraints); !ElemContents(Some(<unique-name(|c)>), type, id', constraints)
  name-unnamed-nodes-and-edges(|c) = EdgeNoDir(?None(); name-unnamed-nodes-and-edges-helper(|c), id) + 
                                 EdgeOut(?None(); name-unnamed-nodes-and-edges-helper(|c), id) +
                                 EdgeIn(id, ?None(); name-unnamed-nodes-and-edges-helper(|c))
  name-unnamed-nodes-and-edges(|c) = ?EdgeOut(); !EdgeOut(<name-unnamed-nodes-and-edges-helper(|c)>, None()) +
                                 ?EdgeIn(); !EdgeIn(None(), <name-unnamed-nodes-and-edges-helper(|c)>)
  name-unnamed-nodes-and-edges-helper(|c) = !ElemContents(Some(<unique-name(|c)> ""), None(), None(), None())
  
  norm-inlined-references = ?ElemContents(Some(varName), _, _, _); alltd(norm-inlined-reference(|varName))
  norm-inlined-reference(|varName) =
      ?Id(); !Id(VarRef(varName)) + ?Label(); !Label(VarRef(varName)) +
      ?Has(props); !Has(VarRef(varName), props) +
      ?InDegree(); !InDegree(VarRef(varName)) +
      ?OutDegree(); !OutDegree(VarRef(varName)) +
      ?Src(); !Src(VarRef(varName)) +
      ?Dst(); !Dst(VarRef(varName)) +
      ?Obj(dot); !VarRef(varName) +
      (?Obj(VarRef(v), dot) + ?PropRef(VarRef(v), _));
          if <eq> (v, varName)
          then !ReferenceInInlinedConstraint(v)
          else !CrossReferenceInInlinedConstraint()
          end +
      (?SelfPropRef(propName) + ?SelfPropRef(dot, propName)); !PropRef(VarRef(varName), propName)

/* PGQL 1.0
rules
  
  norm-UnionGraphPattern:
    UnionGraphPattern(ss, child) -> result
    with
      children := <get-UnionElems> child;
      SubSelect(query) := ss;
      unionElems := [UnionElem(query)|children];
      result := Union(unionElems)

  get-UnionElems:
    None() -> []
  
  get-UnionElems:
    x -> graphPatterns
    where
      Union(SubSelect(query), child) := x
    with
      children := <get-UnionElems> child;
      graphPatterns := [UnionElem(query)|children]
*/

rules
  
  norm-matchElems:
    GraphPattern(elems) -> GraphPattern(nodes, edges, constraints, optionals, unions, expands, subQueries, pathDecls)
    with
      paths := <filter(?Path(_, _, _))> elems;
      inlined-constraints-for-nodes := <collect-om(?Node(<id>)); map(get-inlined-constraints); concat> paths;
      inlined-constraints-for-edges := <collect-om(?EdgeOut(<id>, _) + ?EdgeIn(_, <id>) + ?EdgeNoDir(<id>, _)); map(get-inlined-constraints); concat> paths;
      non-inlined-constraints := <filter(?Constraint(<id>))> elems;
      constraints := <conc; flatten-list; !Constraints(<id>)> (inlined-constraints-for-nodes, inlined-constraints-for-edges, non-inlined-constraints);
      // existsOrNot := <filter(?ExistsFunc(_) + ?Not(ExistsFunc(_)))> constraints;
      // constraints' := <remove-all(?ExistsFunc(_) + ?Not(ExistsFunc(_)))> constraints;
      paths' := <alltd(?ElemContents(Some(<id>), _, _, _))> paths;
      nodes := <collect-om(?Node(_)); !Nodes(<id>)> paths';
      edges := <get-edges; !Edges(<id>)> paths';
      optionals := <filter(?Optional(_)); !Optionals(<id>)> elems;
      unions := <filter(?Union(_)); !Unions(<id>)> elems;
      expands := []; // TODO: remove
      subQueries := [];//<filter(?SubSelect(<id>)); !SubQueries(<id>)> elems; PGQL 1.0
      pathDecls := <filter(?Path(_, _, Some(_)); to-path-decl); !PathDecls(<id>)> paths
  
  get-inlined-constraints:
    ElemContents(Some(var), label, id', otherConstraint) -> [labels, identifiers, otherConstraint']
    with
      labels := <?Some(Labels(<id>)); to-label-constraints(|var) <+ ![]> label;
    	identifiers := <?Some(Ids(<id>)); to-id-constraints(|var) <+ ![]> id';
    	otherConstraint' := <?Some(Constraint(<id>)) <+ ![]> otherConstraint
  
  to-label-constraints(|var) = bottomup(try(is-literal; !Eq(<origin-track-forced(!Label(VarRef(var)))> <id>, <id>)))
  to-id-constraints(|var) = bottomup(try(is-literal; !Eq(Id(VarRef(var)), <id>)))
  
  // base case: no paths
  get-edges:
    [] -> []
  
  // head is path with only one node => get neighbors for the other paths
  get-edges:
    [Path(_, [], _)|otherPaths] -> <get-edges> otherPaths
  
  // paths with more than one node
  get-edges:
    [Path(
      Node(n1),
      edgeNodes@[EdgeNode(e, Node(n2))|_],
      _)
    |otherPaths] -> <conc> ([edge], edgesPathTail, edgesTailPaths)
    with
      edge := <to-edge> (n1, e, n2);
      edgesPathTail := <get-edges> edgeNodes;
      edgesTailPaths := <get-edges> otherPaths
  
  // base case: only one edgeNode
  get-edges:
    [EdgeNode(_, _)] -> []
    
  // two or more edgeNodes
  get-edges:
    [EdgeNode(_, Node(n1)) | edgeNodes@[EdgeNode(e, Node(n2))|_]]
    -> <conc> ([edge], edgesPathTail)
    with
      edge := <to-edge> (n1, e, n2);
      edgesPathTail := <get-edges> edgeNodes
  
  to-edge:
    (n1, e, n2) -> expansion
    with
      switch !e
        case ?EdgeOut(name, lengthProps): expansion := Edge(n1, name, n2, lengthProps)
        case ?EdgeIn(lengthProps, name): expansion := Edge(n2, name, n1, lengthProps)
        case ?EdgeNoDir(name, lengthProps): expansion := Edge(n1, name, n2, lengthProps)
        otherwise: fail
      end
  
  to-path-decl:
    p@Path(_, _, Some(VarAssign(VarDef(v)))) -> PathDecl(v, nodeNames, edgeNames, edgeDirs)
    with
      nodeNames := <collect-om(?Node(ElemContents(Some(<id>), _, _, _)), conc)> p;
      edgeNames := <collect-om(?EdgeOut(ElemContents(Some(<id>), _, _, _), _) + ?EdgeIn(_, ElemContents(Some(<id>), _, _, _)) + ?EdgeNoDir(ElemContents(Some(<id>), _, _, _), _), conc)> p;
      edgeDirs := <collect-om(?EdgeOut(_, _); !Out() + ?EdgeIn(_, _); !In() + ?EdgeNoDir(_, _); !NoDir(), conc)> p
  
rules
  
  norm-has-prop = ?Has(varRef, <id>); map(!Has(varRef, String(<id>))); create-conjunct
  
  create-conjunct = reverse; !(<Tl>, <Hd>); foldl(create-OR)
  create-OR = ?(exp1, exp2); !And(exp1, exp2)

rules
  
  norm-query(|c):
    Query(SelectClause(distinctOrReduced, selectElems), graphName, graphPattern, SolutionModifier(ungroupAs, groupBy, having, orderBy, limitOffsets)) -> Query(graphName, graphPattern, None(), select)
    with
      expAsGroupVars := <?Some(GroupClause(<id>)) <+ ![]> groupBy;
      expAsGroupVars' := <map(norm-expAsGroupVar(|c))> expAsGroupVars;
      groupBy' := <?Some(_); !Some(GroupClause(expAsGroupVars')) <+ !None()> groupBy;

      expAsSelectVars := <?ExpAsVars(<id>); map(replace-terms-with-varRef(|expAsGroupVars')) <+
                          norm-select-star(|graphPattern, expAsGroupVars')> selectElems;
      expAsSelectVars' := <map(name-select-expression(|c))> expAsSelectVars;
      projection' := Vars(ExpAsVars(expAsSelectVars'));
      
      allExpAsVars := <conc> (<remove-all(?ExpAsVar(_, <id>); not(is-aggregate))> expAsSelectVars', expAsGroupVars');
      orderByElems := <try(norm-orderBy(|allExpAsVars))> orderBy;

      limitOffsets' := <norm-limitOffsets> limitOffsets;
      select := Select(distinctOrReduced, projection', groupBy', having, orderByElems, limitOffsets')
  
  norm-select-star(|graphPattern, group-exps):
    Star() -> expAsSelectVars
    with if [] := group-exps
           then vars := <collect((?Node(<id>) + ?Edge(_, <id>, _, _)); not(is-substring(GENERATED)))> graphPattern
           else vars := <map(?ExpAsVar(<id>, _))> group-exps
         end
       ; expAsSelectVars := <map(!ExpAsVar(VarRef(<id>), None()))> vars
  
  norm-expAsGroupVar(|c) = ?ExpAsVar(term, Some(VarAssign(VarDef(v)))); !ExpAsVar(v, term)
  norm-expAsGroupVar(|c) = ?ExpAsVar(term, None()); !ExpAsVar(<origin-text; add-unique-suffix(|c)> term, term)

  norm-select-expression(|group-expressions):
    ExpAsVar(exp, var) -> ExpAsVar(exp', var)
    with exp' := <replace-terms-with-varRef(|group-expressions)> exp
      
  name-select-expression(|c): ExpAsVar(exp, Some(VarAssign(VarDef(v)))) -> ExpAsVar(v, exp)
  name-select-expression(|c):
    ExpAsVar(exp, None()) -> ExpAsVar(v, exp)
    with v := <(origin-text <+ ?VarRef(<id>)); add-unique-suffix(|c)> exp

  replace-terms-with-varRef(|expressions):
    exp -> exp'
    with exp' := <foldl(replace-terms-with-varRef)> (expressions, exp)

  replace-terms-with-varRef = ?(ExpAsVar(var, term), <id>); alltd(
    is-aggregate; ?term; !VarRef(var) + // for ORDER BY
    is-aggregate + ?term; !VarRef(var)) // for SELECT: never look into aggregates

  norm-orderBy(|allExpAsVars):
  	Some(OrderClause(elems)) -> Some(OrderClause(elems'))
  	with
  		elems' := <map(norm-orderBy-ordering); map(norm-order-expression(|allExpAsVars))> elems

  norm-orderBy-ordering =
    ((?Desc1(_, <id>) + ?Desc2(<id>, _)); !OrderByElem(<id>, Desc())) <+
    ((try(?Asc1(_, <id>) + ?Asc2(<id>, _))); !OrderByElem(<id>, Asc()))

  norm-order-expression(|group-and-select-expressions):
  	OrderByElem(exp, ordering) -> OrderByElem(exp', ordering)
  	with
  	  exp' := <replace-terms-with-varRef(|group-and-select-expressions)> exp

  norm-limitOffsets = ?None(); !LimitOffsetClauses(None(), None())
  norm-limitOffsets = ?Some(LimitOffsetClauses(limitClause, offsetClause)); !LimitOffsetClauses(Some(limitClause), offsetClause)
  norm-limitOffsets = ?Some(OffsetLimitClauses(offsetClause, limitClause)); !LimitOffsetClauses(limitClause, Some(offsetClause))

rules // normalization after error checking
  
  normalize-after = oncetd(norm-order-by-aggr-in-select-no-groupBy)

  norm-order-by-aggr-in-select-no-groupBy:
  	Select(distinct, select, groupBy, having, orderByElems, limitOffsets) ->
    Select(distinct, select, groupBy, having, None(), limitOffsets)
    where
    	None() := groupBy;
    	<oncetd(is-aggregate)> select

/*
 * Code below is only temporary until the next verion of Spoofax is released that supports case-insensitive keywords.
 */
rules

  norm-case-insensitive: Label(a, _) -> Label(a)
  norm-case-insensitive: Id(a, _) -> Id(a)
  norm-case-insensitive: Has(a, _, b) -> Has(a, b)
  norm-case-insensitive: InDegree(a, _) -> InDegree(a)
  norm-case-insensitive: OutDegree(a, _) -> OutDegree(a)
  norm-case-insensitive: Src(a, _) -> Src(a)
  norm-case-insensitive: Dst(a, _) -> Dst(a)
  norm-case-insensitive: Nodes(a, _) -> Nodes(a)
  norm-case-insensitive: Edges(a, _) -> Edges(a)
  norm-case-insensitive: Length(a, _) -> Length(a)
  norm-case-insensitive: Head(a, _) -> Head(a)
  norm-case-insensitive: Last(a, _) -> Last(a)
  norm-case-insensitive: Init(a, _) -> Init(a)
  norm-case-insensitive: Tail(a, _) -> Tail(a)
  // TODO: built-ins for Strings and Dates
  norm-case-insensitive: COUNT(_, a, b) -> COUNT(a, b)
  norm-case-insensitive: MIN(_, a, b) -> MIN(a, b)
  norm-case-insensitive: MAX(_, a, b) -> MAX(a, b)
  norm-case-insensitive: SUM(_, a, b) -> SUM(a, b)
  norm-case-insensitive: AVG(_, a, b) -> AVG(a, b)
  // norm-case-insensitive: GROUP-CONCAT(_, a, b, c) -> GROUP-CONCAT(a, b, c)
  norm-case-insensitive: Distinct(_) -> Distinct()
  norm-case-insensitive: True(_) -> True()
  norm-case-insensitive: False(_) -> False()
  norm-case-insensitive: Null(_) -> Null()
  
  norm-case-insensitive: VarAssign(_, a) -> VarAssign(a)
  
  // TODO: paths
  norm-case-insensitive: VarAssign(a, _) -> VarAssign(a)
  
  norm-case-insensitive: GraphPattern1(_, a) -> GraphPattern(a)
  norm-case-insensitive: SelectClause(_, a, b) -> SelectClause(a, b)
  norm-case-insensitive: FromClause(_, a) -> FromClause(a)
  // norm-case-insensitive: Optional(_, a) -> Optional(a)
  // norm-case-insensitive: Union(_, a, b) -> Union(a, b)
  norm-case-insensitive: Constraint(_, a) -> Constraint(a)
  
  norm-case-insensitive: Distinct(_) -> Distinct()
  norm-case-insensitive: UngroupClase(_, a) -> UngroupClase(a)
  norm-case-insensitive: GroupClause(_, _, a) -> GroupClause(a)
  norm-case-insensitive: HavingClause(_, a) -> HavingClause(a)
  norm-case-insensitive: OrderClause(_, _, a) -> OrderClause(a)
  norm-case-insensitive: LimitClause(_, a) -> LimitClause(a)
  norm-case-insensitive: OffsetClause(_, a) -> OffsetClause(a)

  norm-case-insensitive: And2(a, b) -> And(a, b)
  norm-case-insensitive: And3(a, b) -> And(a, b)  
  norm-case-insensitive: Or2(a, b) -> Or(a, b)
  norm-case-insensitive: Or3(a, b) -> Or(a, b)
